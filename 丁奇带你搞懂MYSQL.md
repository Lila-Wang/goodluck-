从原理到实战，丁奇带你搞懂MYSQL（45讲）
https://funnylog.gitee.io/mysql45/

1 MySQL可以分为Server层和存储引擎层两部分。

Server层包括连接器、查询缓存、分析器、优化器、执行器等，涵盖大多数核心服务动能。
存储引擎层负责数据的存储和提取。架构模式是插件式的，支持InnoDB、MyISAM。

2 连接器 -- 查询缓存 -- 分析器 -- 优化器 -- 执行器

（1）连接
连接管理模块，接收请求；连接进程和用户模块，通过，连接线程和客户端对接
（2）查询
查询缓存 Query Cache
分析器，内建解析树，对其语法检查，先from，再on，再join，再where......；检查权限，生成新的解析树，语义检查（没有字段k在这里）等
优化器，将前面解析树转换成执行计划，并进行评估最优
执行器，获取锁，打开表，通过meta数据，获取数据
（3）返回结果
返回给连接进程和用户模块，然后清理，重新等待新的连接

SQL标准的事务隔离级别包括：读未提交（read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（serializable）

读未提交是指，一个事务还没提交时，它做的变更就能被别的事务看到。
读提交是指，一个事务提交之后，它做的变更才会被其他事务看到。
可重复读是指，一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的。
串行化，顾名思义是对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。


row_number(): 同薪不同名，相当于行号，例如3000、2000、2000、1000排名后为1、2、3、4

rank(): 同薪同名，有跳级，例如3000、2000、2000、1000排名后为1、2、2、4

dense_rank(): 同薪同名，无跳级，例如3000、2000、2000、1000排名后为1、2、2、3

ntile(): 分桶排名，即首先按桶的个数分出第一二三桶，然后各桶内从1排名，实际不是很常用


能用单表优先用单表，即便是需要用group by、order by、limit等，效率一般也比多表高

不能用单表时优先用连接，连接是SQL中非常强大的用法，小表驱动大表+建立合适索引+合理运用连接条件，基本上连接可以解决绝大部分问题。但join级数不宜过多，毕竟是一个接近指数级增长的关联效果

能不用子查询、笛卡尔积尽量不用，虽然很多情况下MySQL优化器会将其优化成连接方式的执行过程，但效率仍然难以保证

自定义变量在复杂SQL实现中会很有用，例如LeetCode中困难级别的数据库题目很多都需要借助自定义变量实现


